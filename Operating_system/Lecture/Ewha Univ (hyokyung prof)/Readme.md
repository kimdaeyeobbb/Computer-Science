
# System Structure & Program Execution 

## 컴퓨터 시스템의 구조

- 컴퓨터 내부 장치(Host)
  - CPU, 메모리

- 컴퓨터 외부 장치(I/O device)
  - 하드디스크, 키보드, 마우스, 모니터 등


## Interrupt 

- CPU가 다른 프로그램을 실행하고 있을 때, 입출력 H/W or S/W에 의해 예외상황이 발생하여 처리가 필요한 경우에 CPU에게 이를 알려주는 것

### Interrupt 종류

|H/W Interrupt|S/W Interrupt|
|:--:|:--:|
|I/O Device controller로부터 발생한 Interrupt<br>타이머가 발생시킨 인터럽트|프로그램 오류로 인해 발생하는 인터럽트 (Exception)<br>프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 경우 발생하는 인터럽트(System call)|

- 인터럽트 벡터
  - 특정 인터럽트가 발생했을 때 실행해야할 함수의 위치 주소를 정의해놓은 테이블
  - 해당 인터럽트의 처리 루틴 주소를 가지고 있음

- 인터럽트 처리 루틴
  - 해당 인터럽트를 처리하는 커널 함수
  - 인터럽트 서비스 루틴, 인터럽트 핸들러 라고도 한다. 


### 동기식 입출력과 비동기식 입출력


|동기식 입출력<br>(Synchronous I/O)|비동기식 입출력<br>(asynchronous I/O)|
|:--:|:--:|
|OS(커널)에 I/O 요청 후 입출력 작업이 완료된 후에야 CPU 제어권이 사용자 프로그램에 넘어감<br>주로 입출력 처리에 의해 생성된 결과를 사용해야 하는 경우 활용|운영체제(커널)에 I/O 요청만 해놓고 CPU 제어권을 즉시 돌려받아 다른 작업을 수행함<br>(입출력 작업이 끝날때까지 기다리지 않음)<br>동기식, 비동기식 모두 I/O 처리가 완료됐음을 인터럽트로 알려줌|
|구현방법 1. I/O가 끝날 때까지 프로세스가 CPU를 가지고 있는 방법 (CPU 낭비)<br>구현방법2. I/O가 완료될 때까지 다른 프로그램에게 CPU를 주는 방법|-|


<br><br>

# Process

- 프로세스
    - 실행 중인 프로그램 (program in execution)

- 프로세스의 문맥
  - 프로세스의 출생부터 사망까지를 봤을 때, 현재 시점에서 프로세스가 어떤 상태에 있느냐가 "프로세스의 문맥"이다.
    <br>CPU를 얼마나 썼는가, 메모리를 얼마나 가지고 있었는가 등을 의미한다.

- CPU에서 어디까지 실행했는가(하드웨어 문맥)<br>
Program Counter, 각종 register

<br>

- 프로세스의 주소 공간<br>
code, data, stack

<br>

- 프로세스 관련 커널 자료 구조<br>
PCB(Process Control Block), Kernel stack

<br>

- 프로세스의 상태

  - CPU에서 실행되고 있는 프로세스 (running)
  - CPU를 쓰고 싶지만, 기다리고 있는 프로세스 (ready)
  - 오래걸리는 작업때문에 CPU를 줘도 무의미한 상태, 자신이 요청한 event(i/o)가 만족되지 않아 기다리는 상태 (blocked, wait)


## 문맥 교환

- CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정

- 진행과정
    1. CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
    2. CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴



<br><br>


# Process Management 

## 프로세스 생성 (Process Creation)

- 프로세스 생성 원리: 복제 생성 (부모가 자식을 복제해서 만듦. 자식은 여러명 낳을 수 있음)

- 이로 인해 프로세스의 트리(계층 구조) 형성 (부모가 자식을 여러명 만드는 경우를 떠올릴 것)

- 프로세스가 생성되기 위해서는 자원이 필요하다 (자원은 OS로 부터 받는다)

- 자원의 공유
  - 자원은 부모와 자식이 공유한다 (경우에 따라 자원을 공유하지 않을 수도 있다)
  - 자원을 일부를 공유할 수도, 전혀 공유하지 않을 수도 있다
  
- 수행 (Execution) => 프로세스가 실행이 되는 경우
  - 부모와 자식은 공존하면서 수행되는 모델이다
  - 자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델이다 <b>(blocked 상태)</b>
  

- 프로세스 생성 단계 (2단계를 거침. 각 단계는 독립적)
  1) 부모 프로세스를 복제
  2) 복제된 것에 새로운 프로그램을 덮어 씌우는 단계 
  
- 주소 공간 (Address space)
  - 자식은 부모의 주소 공간을 복사함 (binary, OS data, PCB나 자원들도 복사)
  - 자식은 복제된 공간에 새로운 프로그램을 올림 => 이로인해 서로 다른 프로그램이 컴퓨터 내에 존재할 수 있음
  
 - 유닉스 예시
    1. fork() system call
        - fork() 시스템 콜이 복제를 통해 부모를 그대로 복사하여 새로운 프로세스를 생성
        - 그 과정에서 주소 공간을 할당하게 된다

    2. exec() system call
        - (복제 생성 후) 다른 프로그램으로 덮어 씌우는 역할을 한다
        - fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올린다
        - 이를 통해 새로운 인생을 살 수 있다 (이때까지의 삶이 맘에 들지 않을 경우 모조리 덮어씌울 수 있다)
         
<br>

## 프로세스 종료 (Process Termination)

- 프로세스 세계의 원칙
  - 부모 프로세스가 자식 프로세스를 낳으면 자식이 먼저 종료되어야 함 (이후의 일을 부모가 처리)

1. exit() system call
    - exit 시스템 콜을 하면 자발적으로 프로세스가 종료됨
    - 프로세스가 마지막 명령을 수행한 후 OS에게 이를 알려줌
    - 프로세스의 각종 자원들이 OS에게 반납됨

      - wait() system call
          - 프로세스 종료 시 자식이 부모에게 output data를 보냄 (wait 시스템 콜을 통해 이루어짐)

2. abort() system call
    - 부모 프로세스가 자식의 수행을 종료시킴
    - 비자발적 프로세스 종료
    - abort() system call을 사용하는 경우
        
        1. 자식의 할당 자원이 한계치를 넘어섬
        2. 자식에게 할당된 task가 더 이상 필요하지 않음 (더 이상 자식에게 시킬 일이 없는 경우)
        3. 부모가 종료하는 경우 (프로세스 세계에서는 자식 프로세스가 먼저 종료된 후 부모 프로세스가 종료 되어야 함)
            - 자식부터 죽이면서 위로 올라가면서 종료가 이루어져야 함 
